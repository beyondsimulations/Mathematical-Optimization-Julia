{
  "hash": "bdae4e002c9bfd2a4cfbaa1120a78686",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"JuMP Syntax Cheatsheet\"\nsubtitle: \"Applied Optimization with Julia\"\n\nhtml:\n    theme: litera\n    highlight-style: breezedark\n    linkcolor: \"#a60000\"\n    code-copy: true\n    code-link: true\n    toc: true\npdf: \n    documentclass: report\n    geometry:\n        - margin=1in\n    fontfamily: roboto\n    fontfamilyoptions: sfdefault\n    colorlinks: true\n\nexecute:\n    eval: false\n---\n\n\n\n\n\n\n\n\n# Basic Setup\n\n::: {#665a35f3 .cell execution_count=1}\n``` {.julia .cell-code}\nusing JuMP, HiGHS\n\n# Create a model\nmodel = Model(HiGHS.Optimizer)\n\n# Set optimizer attribute (optional)\nset_optimizer_attribute(model, \"time_limit\", 60.0)\n```\n:::\n\n\n# Variables\n\n## Declaration\n\n::: {#c3e04cac .cell execution_count=2}\n``` {.julia .cell-code}\n# Continuous Variables\n@variable(model, x)                    # Unbounded continuous\n@variable(model, x >= 0)              # Non-negative continuous\n@variable(model, 0 <= x <= 10)        # Bounded continuous\n\n# Integer Variables\n@variable(model, x, Int)              # Unbounded integer\n@variable(model, x >= 0, Int)         # Non-negative integer\n@variable(model, 0 <= x <= 10, Int)   # Bounded integer\n\n# Binary Variables\n@variable(model, x, Bin)              # Binary (0 or 1)\n```\n:::\n\n\n## Containers\n\n::: {#eadfc077 .cell execution_count=3}\n``` {.julia .cell-code}\n# Arrays\n@variable(model, x[1:5])              # Array of 5 variables\n@variable(model, x[1:5] >= 0)         # Non-negative array\n@variable(model, x[1:5], Bin)         # Binary array\n\n# Matrices\n@variable(model, x[1:3, 1:4])         # 3x4 matrix of variables\n@variable(model, x[1:3, 1:4], Int)    # Integer matrix\n\n# Custom Indexing\nindices = [\"A\", \"B\", \"C\"]\n@variable(model, x[i in indices])      # Custom indexed array\n```\n:::\n\n\n# Constraints\n\n## Declaration\n\n::: {#3492c326 .cell execution_count=4}\n``` {.julia .cell-code}\n# Basic constraints\n@constraint(model, con1, 2x + y <= 10)\n@constraint(model, con2, x + 2y >= 5)\n```\n:::\n\n\n## Containers\n\n::: {#2f50a8b6 .cell execution_count=5}\n``` {.julia .cell-code}\n# Array of variables\n@variable(model, x[1:5] >= 0)\n\n# Constraint for each variable\n@constraint(model, capacity[i=1:5], \n    x[i] <= 100\n)\n\n# Sum constraint\n@constraint(model, total_sum,\n    sum(x[i] for i in 1:5) <= 500\n)\n\n# Matrix constraints\n@variable(model, y[1:3, 1:4])\n@constraint(model, matrix_con[i=1:3, j=1:4],\n    y[i,j] <= i + j\n)\n```\n:::\n\n\n## Conditional\n\n::: {#0f1f6a1e .cell execution_count=6}\n``` {.julia .cell-code}\n# Basic conditional constraint\n@constraint(model, cond[i=1:5; i > 2], \n    x[i] <= 10\n)   # Only applies when i > 2\n\n# Multiple conditions\n@constraint(model, cond2[i=1:10, j=1:10; i != j && i + j <= 15],\n    x[i,j] + x[j,i] <= 1\n)\n```\n:::\n\n\n## Key Points for Constraints\n\n- Use semicolon (;) to separate indices from conditions\n- Conditions can use any valid Julia boolean expression\n- Multiple conditions can be combined with && (and) or || (or)\n\n## Conditions while Summing\n\n::: {#77f1b7bf .cell execution_count=7}\n``` {.julia .cell-code}\n@constraint(model, total_sum,\n    sum(x[i] for i in 1:5 if i > 2) <= 500\n)\n# Only sums over i > 2\n\n@constraint(model, total_sum2,\n    sum(x[i,j] for i in 1:5, j in 1:5 if i != j && i + j <= 7) <= 1\n)\n# Only sums over i != j and i + j <= 7\n```\n:::\n\n\n# Objective Function\n\n## Declaration\n\n::: {#4927773c .cell execution_count=8}\n``` {.julia .cell-code}\n# Maximize objective\n@objective(model, Max, 5x + 3y)\n\n# Minimize objective\n@objective(model, Min, 2x + 4y)\n```\n:::\n\n\n## Containers\n\n::: {#67e2fcd7 .cell execution_count=9}\n``` {.julia .cell-code}\n# Container objective\n@variable(model, z[1:10])\n@objective(model, Min, sum(z[i] for i in 1:10))\n\n# Weighted objective\nweights = [1, 2, 3, 4, 5]\n@objective(model, Max, \n    sum(weights[i] * z[i] for i in 1:5)\n)\n```\n:::\n\n\n## Key Points\n\n- Objective functions can be linear or nonlinear\n- Containers are useful for weighted objectives\n- Can reference external data (parameters)\n\n# Additional Features\n\n## Checking Bounds\n\n::: {#8ecb63e3 .cell execution_count=10}\n``` {.julia .cell-code}\n# Checking bounds\nhas_lower_bound(x)                    # Check if lower bound exists\nhas_upper_bound(x)                    # Check if upper bound exists\nlower_bound(x)                        # Get lower bound value\nupper_bound(x)                        # Get upper bound value\n```\n:::\n\n\n## Checking Properties\n\n::: {#450030db .cell execution_count=11}\n``` {.julia .cell-code}\n# Check variable type\nis_binary(x)                          # Is variable binary?\nis_integer(x)                         # Is variable integer?\nis_continuous(x)                      # Is variable continuous?\n\n# Get variable info\nname(x)                              # Get variable name\nnum_variables(model)                 # Count variables in model\nall_variables(model)                 # Get all variables\n```\n:::\n\n\n# Solver Options\n\n::: {#e52e3626 .cell execution_count=12}\n``` {.julia .cell-code}\n# Create model with solver\nmodel = Model(HiGHS.Optimizer)\n\n# Time limits\nset_time_limit_sec(model, 60)         # 60 second limit\ntime_limit_sec(model)                 # Get current time limit\n\n# Tolerance settings\nset_optimizer_attribute(model, \"mip_rel_gap\", 0.01)  # 1% gap tolerance\nset_optimizer_attribute(model, \"mip_abs_gap\", 0.1)   # Absolute gap\n\n# Presolve options\nset_optimizer_attribute(model, \"presolve\", \"on\")     # Enable presolve\nset_optimizer_attribute(model, \"presolve\", \"off\")    # Disable presolve\n```\n:::\n\n\n## Solution Status Checks\n\n::: {#e73ea082 .cell execution_count=13}\n``` {.julia .cell-code}\n# Check solution status\nstatus = termination_status(model)    # Get solution status\nis_optimal = status == MOI.OPTIMAL    # Check if optimal\n\n# Get detailed status\nprimal_status(model)                  # Primal solution status\ndual_status(model)                    # Dual solution status\nsolve_time(model)                     # Solution time\n\n# Common status checks\nif termination_status(model) == OPTIMAL \n    println(\"Solution is optimal\")\nelseif termination_status(model) == TIME_LIMIT && has_values(model)\n    println(\"Time limit reached with feasible solution\")\nelse\n    println(\"Problem could not be solved\")\nend\n```\n:::\n\n\n## Key Points\n\n- Always check solution status before using results\n- Set appropriate time limits for large problems\n- Use gap tolerances to balance precision and speed\n- Monitor solve time for performance optimization\n- Consider presolve for complex problems\n\n",
    "supporting": [
      "cheatsheet-jump_files"
    ],
    "filters": [],
    "includes": {}
  }
}