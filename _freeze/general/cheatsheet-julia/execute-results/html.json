{
  "hash": "78aa7b4200f364a0c774b0387ef88bb9",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Julia Syntax Cheatsheet\"\nsubtitle: \"Applied Optimization with Julia\"\n\nhtml:\n    theme: [default, ../styles.scss]\n    highlight-style: breezedark\n    linkcolor: \"#a60000\"\n    code-copy: true\n    code-link: true\n    toc: true\npdf: \n    documentclass: report\n    geometry:\n        - margin=1in\n    fontfamily: roboto\n    fontfamilyoptions: sfdefault\n    colorlinks: true\n\nexecute:\n    eval: false\n---\n\n\n\n\n\n\n\n\n# Variables and Basic Types\n\n## Variable Declaration and Types\n\n::: {#1b90f825 .cell execution_count=1}\n``` {.julia .cell-code}\n# Basic variable declaration\nx = 1                  # Implicit typing\ny::Int64 = 5          # Explicit type annotation\n\n# Common types\nnum_int = 42          # Integer\nnum_float = 19.99     # Float\nis_student = true     # Boolean\nname = \"Julia\"        # String\n\n# Check type\ntypeof(num_int)       # Returns Int64\ntypeof(num_float)     # Returns Float64\n```\n:::\n\n\n## String Interpolation\n\n::: {#d8f518c4 .cell execution_count=2}\n``` {.julia .cell-code}\nname = \"Julia\"\nage = 30\n# Basic interpolation\nmessage = \"I am $age years old\"\n# Complex interpolation\ngreeting = \"Hello, my name is $name and I am $age years old\"\n```\n:::\n\n\n## Type Conversion\n\n::: {#a45cabff .cell execution_count=3}\n``` {.julia .cell-code}\n# Convert between types\nfloat_num = Float64(42)    # Int to Float\nint_num = Int64(3.14)      # Float to Int\nstr_num = string(42)       # Number to String\n```\n:::\n\n\n# Key Points\n\n- Variables are dynamic, types are not\n- Use `typeof()` to check variable type\n- String interpolation is powerful for formatted output\n\n# Vectors, Matrices, and Tuples\n\n## Vectors\n\n::: {#63d8f50d .cell execution_count=4}\n``` {.julia .cell-code}\n# Create vectors\ngrades = [95, 87, 91, 78, 88]    # Numeric vector\nnames = [\"Mike\", \"Yola\", \"Elio\"] # String vector\n\n# Vector operations\npush!(grades, 82)       # Add element to end\npop!(grades)           # Remove last element\npopfirst!(grades)      # Remove first element\n\n# Vector indexing\nfirst = grades[1]      # Access first element\nsubset = grades[1:3]   # Access first three elements\n```\n:::\n\n\n## Matrices\n\n::: {#07e6e96a .cell execution_count=5}\n``` {.julia .cell-code}\n# Create matrices\nmatrix = [1 2 3; 4 5 6]    # 2x3 matrix\n# Matrix operations\nmatrix[2,3] = 17           # Change specific element\n\n# Matrix arithmetic\nmatrix1 = [2 2; 3 3]\nmatrix2 = [1 2; 3 4]\nsum_matrix = matrix1 + matrix2      # Matrix addition\nprod_matrix = matrix1 * matrix2     # Matrix multiplication\nelement_prod = matrix1 .* matrix2   # Element-wise multiplication\n\n# Broadcasting\nmatrix .+ 10                # Add 10 to each element\n```\n:::\n\n\n## Tuples\n\n::: {#4cfc9aef .cell execution_count=6}\n``` {.julia .cell-code}\n# Create tuples (immutable)\nperson = (\"Elio Smith\", 18, \"Hamburg\")\nrgb = (255, 0, 0)\n\n# Tuple operations\nname = person[1]           # Access first element\nage, city = person[2:3]    # Multiple assignment\n```\n:::\n\n\n## Key Differences\n\n- Vectors: Mutable, 1-dimensional, good for lists\n- Matrices: Mutable, 2-dimensional, good for linear algebra\n- Tuples: Immutable, fixed-size, good for grouping related constants\n\n# Comparison and Logical Operators\n\n## Basic Comparisons\n\n::: {#e47657ac .cell execution_count=7}\n``` {.julia .cell-code}\n# Comparison operators\nx == y    # Equal to\nx != y    # Not equal to\nx < y     # Less than\nx > y     # Greater than\nx <= y    # Less than or equal to\nx >= y    # Greater than or equal to\n\n# Examples\npassword_correct = (input == \"secret123\")\nis_adult = (age >= 18)\ncan_afford = (price <= budget)\n```\n:::\n\n\n## Logical Operators\n\n::: {#e45f9e6e .cell execution_count=8}\n``` {.julia .cell-code}\n# AND operator (&&)\ncan_buy = (age >= 18) && (money >= price)    # Both conditions must be true\n\n# OR operator (||)\nneed_coat = (temp < 10) || is_raining        # At least one must be true\n\n# NOT operator (!)\nis_closed = !is_open                         # Inverts boolean value\n```\n:::\n\n\n## Chained Comparisons\n\n::: {#b532cf64 .cell execution_count=9}\n``` {.julia .cell-code}\n# Instead of\nx >= 0 && x <= 10    # Check if x is between 0 and 10\n\n# You can write\n0 <= x <= 10         # More natural syntax\n\n# Real-world examples\nnormal_temp = 36.5 <= body_temp <= 37.5\nwork_hours = 9 <= current_hour < 17\n```\n:::\n\n\n## Key Points\n\n- Comparisons return boolean values (`true` or `false`)\n- `&&` requires all conditions to be true\n- `||` requires at least one condition to be true\n- `!` inverts a boolean value\n- Chained comparisons make range checks more readable\n\n# Loops and Iterations\n\n## For Loops\n\n::: {#3edf0835 .cell execution_count=10}\n``` {.julia .cell-code}\n# Basic for loop with range\nfor i in 1:3\n    println(i)        # Prints 1, 2, 3\nend\n\n# Iterating over array\nfruits = [\"apple\", \"banana\", \"cherry\"]\nfor fruit in fruits\n    println(fruit)    # Prints each fruit\nend\n\n# For loop with break\nfor x in 1:10\n    if x == 4\n        break        # Exits loop when x is 4\n    end\nend\n\n# For loop with conditions\nfor x in 1:10\n    if x <= 2\n        println(x)\n    elseif x == 3\n        println(\"Three!\")\n    else \n        break\n    end\nend\n```\n:::\n\n\n## While Loops\n\n::: {#0db802f9 .cell execution_count=11}\n``` {.julia .cell-code}\n# Basic while loop\nnumber = 10\nwhile number >= 5\n    number -= 1      # Decrements until < 5\nend\n\n# Infinite loop with break\ncurrent = 0\nwhile true\n    current += 1\n    if current == 5\n        break        # Exits when condition met\n    end\nend\n\n# While loop with condition\nlives = 3\nwhile lives > 0\n    lives -= 1       # Continues until lives = 0\nend\n```\n:::\n\n\n## Nested Loops\n\n::: {#06e055ac .cell execution_count=12}\n``` {.julia .cell-code}\n# Nested loop example\nsizes = [\"S\", \"M\", \"L\"]\ncolors = [\"Red\", \"Blue\"]\nfor size in sizes\n    for color in colors\n        println(\"$color $size\")\n    end\nend\n\n# Matrix iteration\nfor i in 1:3\n    for j in 1:2\n        println(\"Position: $i,$j\")\n    end\nend\n```\n:::\n\n\n## List Comprehensions\n\n::: {#44a436cc .cell execution_count=13}\n``` {.julia .cell-code}\n# Basic list comprehension\nsquares = [n^2 for n in 1:5]    # [1,4,9,16,25]\n\n# With condition\nevens = [n for n in 1:10 if n % 2 == 0]    # [2,4,6,8,10]\n\n# Nested comprehension\nmatrix = [i*j for i in 1:3, j in 1:3]    # 3x3 multiplication table\n```\n:::\n\n\n## Key Points\n\n- `for` loops are best when you know the number of iterations\n- `while` loops are useful for unknown iteration counts\n- Use `break` to exit loops early\n- List comprehensions offer concise array creation\n- Nested loops are useful for multi-dimensional iteration\n\n# Dictionaries\n\n## Basic Dictionary Operations\n\n::: {#ea1d9748 .cell execution_count=14}\n``` {.julia .cell-code}\n# Create a dictionary\nstudent_ids = Dict(\n    \"Elio\" => 1001,\n    \"Bob\" => 1002,\n    \"Yola\" => 1003\n)\n\n# Access values\nid = student_ids[\"Elio\"]        # Get value by key\nstudent_ids[\"David\"] = 1004     # Add new key-value pair\ndelete!(student_ids, \"Bob\")     # Remove entry\n\n# Check key existence\nif haskey(student_ids, \"Eve\")\n    println(student_ids[\"Eve\"])\nend\n```\n:::\n\n\n## Advanced Operations\n\n::: {#0322453d .cell execution_count=15}\n``` {.julia .cell-code}\n# Dictionary with array values\ngrades = Dict(\n    \"Elio\" => [85, 92, 78],\n    \"Bob\" => [76, 88, 94]\n)\n\n# Get all keys and values\nnames = keys(grades)          # Get all keys\nscores = values(grades)       # Get all values\n\n# Iterate over dictionary\nfor (student, grade_list) in grades\n    avg = sum(grade_list) / length(grade_list)\n    println(\"$student: $avg\")\nend\n```\n:::\n\n\n## Common Methods\n\n::: {#c304bbb2 .cell execution_count=16}\n``` {.julia .cell-code}\n# Dictionary methods\nlength(dict)           # Number of entries\nempty!(dict)           # Remove all entries\nget(dict, key, default)# Get value or default if key missing\nmerge(dict1, dict2)    # Combine two dictionaries\ncopy(dict)             # Create shallow copy\n```\n:::\n\n\n## Key Points\n\n- Keys must be unique\n- Values can be of any type (including arrays)\n- Use `haskey()` to safely check for key existence\n- Dictionaries are mutable (can be changed)\n- Keys are accessed with square brackets `dict[\"key\"]`\n\n# Functions\n\n## Basic Function Definition\n\n::: {#68bde85f .cell execution_count=17}\n``` {.julia .cell-code}\n# Basic function with explicit return\nfunction say_hello(name)\n    return \"Hello, $(name)!\"\nend\n\n# Function with implicit return\nfunction multiply(a, b)\n    a * b    # Last expression is automatically returned\nend\n\n# Conditional return\nfunction do_something(a, b)\n    if a > b\n        return a * b\n    else\n        return a + b\n    end\nend\n```\n:::\n\n\n## Function Scope\n\n::: {#a358f3a3 .cell execution_count=18}\n``` {.julia .cell-code}\n# Local scope example\nfunction bake_cake()\n    secret_ingredient = \"vanilla\"    # Only exists inside function\n    return secret_ingredient        # Must return to access outside\nend\n\n# Variables outside function not accessible inside\nglobal_var = 10\nfunction scope_example()\n    # Can read global_var but can't modify it\n    return global_var + 5\nend\n```\n:::\n\n\n## Multiple Dispatch\n\n::: {#b93956ce .cell execution_count=19}\n``` {.julia .cell-code}\n# Generic operation for all types\nfunction operation(a, b)\n    \"Generic operation for $(typeof(a)) and $(typeof(b))\"\nend\n\n# Type-specific implementations\noperation(a::Number, b::Number) = a + b        # For numbers\noperation(a::String, b::String) = string(a, b) # For strings\n\n# Usage examples\noperation(10, 20)          # Returns 30\noperation(\"Hello\", \"!\")    # Returns \"Hello!\"\noperation(\"Hi\", 42)        # Uses generic operation\n```\n:::\n\n\n## Key Points\n\n- Functions can have explicit or implicit returns\n- Last expression is automatically returned if no `return` statement\n- Variables inside functions are local by default\n- Multiple dispatch allows different behavior based on argument types\n- Use `return` for early exits or conditional \n\n# Package Management\n\n## Basic Package Operations\n\n::: {#0345d69f .cell execution_count=20}\n``` {.julia .cell-code}\n# Import package manager\nimport Pkg              # Access as Pkg.function()\nusing Pkg              # Import all exported names\n\n# Add packages\nPkg.add(\"DataFrames\")  # Add single package\nPkg.add([\"Package1\", \"Package2\"])  # Add multiple packages\n\n# Update packages\nPkg.update()           # Update all packages\nPkg.update(\"DataFrames\")  # Update specific package\n\n# Remove packages\nPkg.rm(\"DataFrames\")   # Remove package\n```\n:::\n\n\n## Package Usage\n\n::: {#384d06ff .cell execution_count=21}\n``` {.julia .cell-code}\n# Import packages\nimport DataFrames     # Access as DataFrames.function()\nusing DataFrames     # Import all exported names\n\n# Check installed packages\nPkg.status()         # List all installed packages\n```\n:::\n\n\n## Environment Management\n\n::: {#5b571e2e .cell execution_count=22}\n``` {.julia .cell-code}\n# Environment operations\nPkg.activate(\"new_environment\")    # Create/activate environment\nPkg.activate()                     # Activate default environment\n\n# Project files\n# Project.toml    - Lists direct dependencies\n# Manifest.toml   - Complete dependency graph\n```\n:::\n\n\n## Key Points\n\n- Use `import` for namespace control, `using` for direct access\n- Always update packages regularly with `Pkg.update()`\n- Create separate environments for different projects\n- Project.toml and Manifest.toml track dependencies\n- Package manager commands typically run in REPL\n\n# DataFrames\n\n## Creating DataFrames\n\n::: {#77670c52 .cell execution_count=23}\n``` {.julia .cell-code}\nusing DataFrames\n\n# Basic DataFrame creation\ndf = DataFrame(\n    Name = [\"John\", \"Mike\", \"Frank\"],\n    Age = [28, 23, 37],\n    Salary = [50000, 62000, 90000]\n)\n\n# Empty DataFrame with specified columns\ndf_empty = DataFrame(\n    Name = String[],\n    Age = Int[]\n)\n```\n:::\n\n\n## Accessing and Modifying Data\n\n::: {#b046a3f2 .cell execution_count=24}\n``` {.julia .cell-code}\n# Access columns\nages = df.Age                # Get Age column\nfirst_name = df.Name[1]      # First name in Name column\n\n# Modify values\ndf.Salary[1] = 59000        # Update John's salary\ndf.NewColumn = zeros(3)     # Add new column\n\n# Access multiple columns\nsubset = df[:, [:Name, :Age]]  # Select specific columns\nrow = df[1, :]                 # Select first row\n```\n:::\n\n\n## Filtering Data\n\n::: {#fddbe5c6 .cell execution_count=25}\n``` {.julia .cell-code}\n# Filter with boolean indexing\nhigh_earners = df[df.Salary .> 60000, :]\n\n# Using filter function\nhigh_earners = filter(row -> row.Salary > 60000, df)\n\n# Multiple conditions\nsenior_high_earners = df[(df.Age .> 30) .& (df.Salary .> 60000), :]\n```\n:::\n\n\n## Data Manipulation\n\n::: {#538b303a .cell execution_count=26}\n``` {.julia .cell-code}\n# Sort DataFrame\nsorted_df = sort(df, :Age)               # Sort by Age\nsorted_df = sort(df, [:Age, :Salary])    # Sort by multiple columns\n\n# Add calculated column\ndf.Bonus = [row.Age > 30 ? row.Salary * 0.1 : row.Salary * 0.05 for row in eachrow(df)]\n\n# Iterate over rows\nfor row in eachrow(df)\n    println(\"$(row.Name): $(row.Age) years old\")\nend\n```\n:::\n\n\n## Key Functions\n\n::: {#4c1bb445 .cell execution_count=27}\n``` {.julia .cell-code}\nnrow(df)              # Number of rows\nncol(df)              # Number of columns\nnames(df)             # Column names\ndescribe(df)          # Summary statistics\npush!(df, row)        # Add new row\nselect(df, :Name)     # Select columns\n```\n:::\n\n\n## Key Points\n\n- Column access with dot notation (df.column)\n- Use eachrow() for row iteration\n- Boolean indexing for filtering\n- push! to add new rows\n- Broadcasting with dot operators (.>, .+, etc.)\n\n# File Input/Output\n\n## DelimitedFiles Operations\n\n::: {#e06b3f1a .cell execution_count=28}\n``` {.julia .cell-code}\nusing DelimitedFiles\n\n# Write matrix to CSV\ndata = [1 2 3; 4 5 6]\nwritedlm(\"data.csv\", data, ',')      # Write with comma delimiter\nwritedlm(\"data.txt\", data, '\\t')     # Write with tab delimiter\n\n# Read delimited files\nmatrix = readdlm(\"data.csv\", ',')    # Read CSV file\nmatrix = readdlm(\"data.txt\", '\\t')   # Read tab-delimited file\n```\n:::\n\n\n## CSV and DataFrame Operations\n\n::: {#f86a969b .cell execution_count=29}\n``` {.julia .cell-code}\nusing CSV, DataFrames\n\n# Write DataFrame to CSV\ndf = DataFrame(\n    Name = [\"John\", \"Alice\"],\n    Age = [25, 30]\n)\nCSV.write(\"data.csv\", df)            # Basic write\nCSV.write(\"data.csv\", df,            # Write with options\n    delim = ';',                     # Custom delimiter\n    header = false                   # No header\n)\n\n# Read CSV to DataFrame\ndf = CSV.read(\"data.csv\", DataFrame)           # Basic read\ndf = CSV.read(\"data.csv\", DataFrame,           # Read with options\n    delim = ';',                               # Custom delimiter\n    header = [\"Col1\", \"Col2\"]                  # Custom headers\n)\n```\n:::\n\n\n## File Path Management\n\n::: {#2f42f9ca .cell execution_count=30}\n``` {.julia .cell-code}\n# Get current directory\n@__DIR__                             # Directory of current file\npwd()                                # Current working directory\n\n# Path operations\npath = joinpath(@__DIR__, \"data\")    # Join path components\nmkdir(path)                          # Create directory\nisfile(path)                         # Check if file exists\n```\n:::\n\n\n## Key Points\n\n- Use DelimitedFiles for simple matrix I/O\n- CSV package for advanced DataFrame I/O\n- Always use @__DIR__ for relative paths\n- Check file existence before operations\n- Consider using try-catch for file operations\n\n# Plotting with Plots.jl\n\n## Basic Plots\n\n::: {#aedc4c05 .cell execution_count=31}\n``` {.julia .cell-code}\nusing Plots, StatsPlots\n\n# Line plot\nplot(x, y,\n    title=\"Line Plot\",\n    xlabel=\"X Label\",\n    ylabel=\"Y Label\",\n    legend=false\n)\n\n# Scatter plot\nscatter(x, y,\n    title=\"Scatter Plot\",\n    marker=(:circle, 8)\n)\n\n# Bar plot\nbar(categories, values,\n    title=\"Bar Plot\"\n)\n\n# Histogram\nhistogram(data,\n    bins=30,\n    title=\"Histogram\"\n)\n\n# Box plot\nboxplot(group, values,\n    title=\"Box Plot\"\n)\n```\n:::\n\n\n## Plot Customization\n\n::: {#fe7ee8cf .cell execution_count=32}\n``` {.julia .cell-code}\n# Customize plot appearance\nplot(x, y,\n    title=\"Custom Plot\",\n    line=(:dash, 2),      # Line style and width\n    color=:red,           # Line color\n    marker=(:circle, 8),  # Marker style and size\n    label=\"Data Series\"   # Legend label\n)\n\n# Multiple series\nplot(x, y1, label=\"Series 1\")\nplot!(x, y2, label=\"Series 2\")  # Add to existing plot\n```\n:::\n\n\n## Saving Plots\n\n::: {#bd26cc59 .cell execution_count=33}\n``` {.julia .cell-code}\n# Save plot to file\nsavefig(plot_name, \"path/plot.png\")  # Save as PNG\nsavefig(plot_name, \"path/plot.pdf\")  # Save as PDF\nsavefig(plot_name, \"path/plot.svg\")  # Save as SVG\n```\n:::\n\n\n## Common Options\n\n::: {#a858348c .cell execution_count=34}\n``` {.julia .cell-code}\n# Plot options\nplot(\n    legend=true/false,    # Show/hide legend\n    grid=true/false,      # Show/hide grid\n    size=(width,height),  # Plot dimensions\n    dpi=300              # Resolution\n)\n\n# Line styles\n:solid, :dash, :dot\n\n# Colors\n:red, :blue, :green\n\n# Markers\n:circle, :square, :diamond\n```\n:::\n\n\n## Key Points\n\n- Use plot() for new plots, plot!() to add to existing\n- Customize with named arguments\n- Save plots in various formats\n- StatsPlots extends plotting capabilities\n- Multiple series can share one plot\n\n",
    "supporting": [
      "cheatsheet-julia_files"
    ],
    "filters": [],
    "includes": {}
  }
}